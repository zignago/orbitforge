"""Preprocessor for converting STEP files to Nastran BDF format.

This module handles the conversion of STEP geometry files along with
mission loads into MSC Nastran input files (.bdf format).
"""

import math
from pathlib import Path
from typing import Dict, List, Tuple, Optional

import numpy as np
from loguru import logger

try:
    import gmsh

    GMSH_AVAILABLE = True
except ImportError:
    logger.warning("GMSH not available - mesh generation will be disabled")
    GMSH_AVAILABLE = False


class MeshGenerator:
    """Generates finite element meshes from STEP files."""

    def __init__(self, mesh_size: float = 2.0):
        """Initialize mesh generator.

        Args:
            mesh_size: Target mesh element size in mm
        """
        self.mesh_size = mesh_size

    def step_to_mesh(self, step_file: Path) -> Tuple[np.ndarray, np.ndarray]:
        """Convert STEP file to finite element mesh.

        Args:
            step_file: Path to STEP file

        Returns:
            Tuple of (nodes, elements) arrays
            - nodes: (N, 3) array of node coordinates
            - elements: (M, 4) array of element node indices (CQUAD4)

        Raises:
            RuntimeError: If GMSH is not available or meshing fails
        """
        if not GMSH_AVAILABLE:
            raise RuntimeError("GMSH not available for mesh generation")

        try:
            # Initialize GMSH
            gmsh.initialize()
            gmsh.option.setNumber("General.Terminal", 0)  # Suppress output

            # Import STEP file
            gmsh.model.occ.importShapes(str(step_file))
            gmsh.model.occ.synchronize()

            # Set mesh size
            gmsh.model.mesh.setSize(gmsh.model.getEntities(0), self.mesh_size)

            # Generate 2D mesh (surfaces only for cubesat frames)
            gmsh.model.mesh.generate(2)

            # Get nodes and elements
            node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
            element_types, element_tags, element_node_tags = (
                gmsh.model.mesh.getElements()
            )

            # Process nodes
            nodes = np.array(node_coords).reshape(-1, 3)

            # Process elements (focus on quadrilaterals)
            elements = []
            for elem_type, tags, node_tags in zip(
                element_types, element_tags, element_node_tags
            ):
                if elem_type == 3:  # 4-node quadrilateral
                    quads = np.array(node_tags).reshape(-1, 4)
                    elements.append(quads)
                elif elem_type == 2:  # 3-node triangle - convert to degenerate quad
                    tris = np.array(node_tags).reshape(-1, 3)
                    # Make degenerate quads by repeating last node
                    degenerate_quads = np.column_stack([tris, tris[:, -1]])
                    elements.append(degenerate_quads)

            if elements:
                elements = np.vstack(elements)
            else:
                raise RuntimeError("No suitable elements found in mesh")

            logger.info(
                f"Generated mesh with {len(nodes)} nodes and {len(elements)} elements"
            )

            return nodes, elements

        except Exception as e:
            logger.error(f"Mesh generation failed: {e}")
            raise RuntimeError(f"Failed to generate mesh from {step_file}: {e}") from e
        finally:
            gmsh.finalize()


class BDFWriter:
    """Writes Nastran BDF files from mesh and load data."""

    def __init__(self):
        """Initialize BDF writer."""
        pass

    def write_bdf(
        self,
        output_file: Path,
        nodes: np.ndarray,
        elements: np.ndarray,
        material_props: Dict[str, float],
        loads: Dict[str, float],
        constraints: Optional[List[int]] = None,
    ) -> None:
        """Write BDF file from mesh and load data.

        Args:
            output_file: Output BDF file path
            nodes: (N, 3) array of node coordinates
            elements: (M, 4) array of element node indices
            material_props: Material properties dict
            loads: Load specification dict
            constraints: List of constrained node IDs (optional)
        """
        try:
            with open(output_file, "w") as f:
                # Write header
                f.write("$ Nastran BDF file generated by OrbitForge\n")
                f.write("$ \n")
                f.write("SOL 101\n")
                f.write("CEND\n")
                f.write("$ \n")
                f.write("$ EXECUTIVE CONTROL DECK\n")
                f.write("$ \n")
                f.write("BEGIN BULK\n")
                f.write("$ \n")

                # Write material card
                self._write_material_card(f, material_props)

                # Write property card
                self._write_property_card(f, material_props)

                # Write nodes
                self._write_nodes(f, nodes)

                # Write elements
                self._write_elements(f, elements)

                # Write constraints
                if constraints:
                    self._write_constraints(f, constraints)
                else:
                    # Default: constrain corner nodes
                    self._write_default_constraints(f, nodes)

                # Write loads
                self._write_loads(f, loads, len(nodes))

                # Write load case
                f.write("$ Load case definition\n")
                f.write("SUBCASE 1\n")
                f.write("    LABEL = Static Analysis\n")
                f.write("    SPC = 1\n")
                f.write("    LOAD = 1\n")
                f.write("    STRESS = ALL\n")
                f.write("    DISPLACEMENT = ALL\n")
                f.write("$ \n")

                f.write("ENDDATA\n")

            logger.info(f"Written BDF file to {output_file}")

        except Exception as e:
            logger.error(f"Failed to write BDF file: {e}")
            raise RuntimeError(f"Failed to write BDF file to {output_file}: {e}") from e

    def _write_material_card(self, f, material_props: Dict[str, float]) -> None:
        """Write material card (MAT1)."""
        E = material_props.get("elastic_modulus", 70e9)  # Pa
        nu = material_props.get("poisson_ratio", 0.33)
        rho = material_props.get("density", 2700)  # kg/m3

        # Convert to Nastran units (N, mm, s, kg)
        E_nastran = E * 1e-6  # Pa to N/mm2
        rho_nastran = rho * 1e-12  # kg/m3 to kg/mm3

        f.write("$ Material properties\n")
        f.write(f"MAT1    1       {E_nastran:.2E}{nu:8.3f}        {rho_nastran:.2E}\n")
        f.write("$ \n")

    def _write_property_card(self, f, material_props: Dict[str, float]) -> None:
        """Write property card (PSHELL)."""
        thickness = material_props.get("thickness", 1.0)  # mm

        f.write("$ Shell property\n")
        f.write(f"PSHELL  1       1       {thickness:.3f}\n")
        f.write("$ \n")

    def _write_nodes(self, f, nodes: np.ndarray) -> None:
        """Write node cards (GRID)."""
        f.write("$ Grid points\n")
        for i, (x, y, z) in enumerate(nodes, 1):
            f.write(f"GRID    {i:8d}        {x:8.3f}{y:8.3f}{z:8.3f}\n")
        f.write("$ \n")

    def _write_elements(self, f, elements: np.ndarray) -> None:
        """Write element cards (CQUAD4)."""
        f.write("$ Shell elements\n")
        for i, elem_nodes in enumerate(elements, 1):
            n1, n2, n3, n4 = elem_nodes
            f.write(f"CQUAD4  {i:8d}1       {n1:8d}{n2:8d}{n3:8d}{n4:8d}\n")
        f.write("$ \n")

    def _write_constraints(self, f, constrained_nodes: List[int]) -> None:
        """Write constraint cards (SPC1)."""
        f.write("$ Constraints\n")
        f.write("SPC1    1       123456  ")
        for i, node_id in enumerate(constrained_nodes):
            if i > 0 and i % 6 == 0:  # New line every 6 nodes
                f.write("\n+       ")
            f.write(f"{node_id:8d}")
        f.write("\n$ \n")

    def _write_default_constraints(self, f, nodes: np.ndarray) -> None:
        """Write default constraints (fix corner nodes)."""
        # Find corner nodes (nodes with extreme coordinates)
        n_nodes = len(nodes)
        if n_nodes < 4:
            constrained = [1]  # Just fix first node if too few nodes
        else:
            # Find nodes at corners of bounding box
            min_coords = np.min(nodes, axis=0)
            max_coords = np.max(nodes, axis=0)

            corner_candidates = []
            tolerance = 1e-3

            for i, node in enumerate(nodes):
                is_corner = (
                    (
                        abs(node[0] - min_coords[0]) < tolerance
                        or abs(node[0] - max_coords[0]) < tolerance
                    )
                    and (
                        abs(node[1] - min_coords[1]) < tolerance
                        or abs(node[1] - max_coords[1]) < tolerance
                    )
                    and (
                        abs(node[2] - min_coords[2]) < tolerance
                        or abs(node[2] - max_coords[2]) < tolerance
                    )
                )
                if is_corner:
                    corner_candidates.append(i + 1)  # 1-based indexing

            constrained = corner_candidates[:4] if corner_candidates else [1, 2, 3, 4]

        self._write_constraints(f, constrained)

    def _write_loads(self, f, loads: Dict[str, float], n_nodes: int) -> None:
        """Write load cards (FORCE)."""
        f.write("$ Applied loads\n")

        # Default loads based on typical cubesat requirements
        accel_x = loads.get("accel_x", 0.0)  # g
        accel_y = loads.get("accel_y", 0.0)  # g
        accel_z = loads.get("accel_z", 9.81)  # g (gravity)

        load_case_id = 1

        # Apply as distributed load on all nodes
        if accel_x != 0.0 or accel_y != 0.0 or accel_z != 0.0:
            for node_id in range(1, n_nodes + 1):
                if accel_x != 0.0:
                    f.write(
                        f"FORCE   {load_case_id}{node_id:8d}        {accel_x*9810:.2f}1.0     0.0     0.0\n"
                    )
                if accel_y != 0.0:
                    f.write(
                        f"FORCE   {load_case_id}{node_id:8d}        {accel_y*9810:.2f}0.0     1.0     0.0\n"
                    )
                if accel_z != 0.0:
                    f.write(
                        f"FORCE   {load_case_id}{node_id:8d}        {accel_z*9810:.2f}0.0     0.0     1.0\n"
                    )

        f.write("$ \n")


def convert_step_to_bdf(
    step_file: Path,
    output_file: Path,
    material_props: Dict[str, float],
    loads: Dict[str, float],
    mesh_size: float = 2.0,
) -> None:
    """Convert STEP file to Nastran BDF format.

    Args:
        step_file: Input STEP file path
        output_file: Output BDF file path
        material_props: Material properties dictionary
        loads: Load specification dictionary
        mesh_size: Target mesh element size in mm

    Raises:
        RuntimeError: If conversion fails
    """
    try:
        # Generate mesh from STEP file
        mesher = MeshGenerator(mesh_size)
        nodes, elements = mesher.step_to_mesh(step_file)

        # Write BDF file
        bdf_writer = BDFWriter()
        bdf_writer.write_bdf(output_file, nodes, elements, material_props, loads)

        logger.info(f"Successfully converted {step_file} to {output_file}")

    except Exception as e:
        logger.error(f"STEP to BDF conversion failed: {e}")
        raise RuntimeError(f"Failed to convert {step_file} to BDF: {e}") from e
